# s5cmd aliases - fast S3 client
alias s5='s5cmd'

# duckdb aliases - analytical SQL database
alias ddb='duckdb'

pq() {
  # Read Parquet files and output newline-delimited JSON, pipeable into jq.
  #
  # Usage:
  #   pq <path>                          # dump all rows
  #   pq <path> 10                       # first 10 rows
  #   pq <path> | jq '.col_name'         # pipe to jq
  #   pq <path> -q "SELECT * FROM data WHERE x > 5"  # custom SQL
  #
  # <path> can be local, s3://, or a glob (e.g. s3://bucket/prefix/*.parquet)

  if [ $# -lt 1 ]; then
    echo "Usage: pq <parquet_path> [limit] [-q <sql>]" >&2
    echo "  parquet_path  Local path or s3:// URI (globs supported)" >&2
    echo "  limit         Max rows to return (default: all)" >&2
    echo "  -q <sql>      Custom SQL query (use 'data' as the table name)" >&2
    return 1
  fi

  local path="$1"
  shift

  local limit=""
  local query=""

  while [ $# -gt 0 ]; do
    case "$1" in
      -q|--query)
        query="$2"
        shift 2
        ;;
      *)
        limit="$1"
        shift
        ;;
    esac
  done

  local sql
  if [ -n "$query" ]; then
    sql="CREATE OR REPLACE VIEW data AS SELECT * FROM read_parquet('${path}'); COPY (${query}) TO '/dev/stdout' (FORMAT JSON, ARRAY false);"
  elif [ -n "$limit" ]; then
    sql="COPY (SELECT * FROM read_parquet('${path}') LIMIT ${limit}) TO '/dev/stdout' (FORMAT JSON, ARRAY false);"
  else
    sql="COPY (SELECT * FROM read_parquet('${path}')) TO '/dev/stdout' (FORMAT JSON, ARRAY false);"
  fi
  duckdb -c "$sql" 2>/dev/null
}

livefreq() {
  # Usage: your_cmd | livefreq [interval_seconds]
  # Requires: gawk
  gawk -v INTERVAL="${1:-1}" '
  BEGIN {
    first = 1
    last = systime()
    last_lines = 0

    cols = (ENVIRON["COLUMNS"] + 0 ? ENVIRON["COLUMNS"] + 0 : 120)
    # width budget for: count(15) + space + percent(8) + two spaces = 26
    valw = cols - 26
    if (valw < 20) valw = 20
  }

  function commify(n, s, sign, out) {
    # robust comma formatting using strings (portable)
    s = sprintf("%.0f", n)
    sign = ""
    if (substr(s, 1, 1) == "-") { sign = "-"; s = substr(s, 2) }
    out = ""
    while (length(s) > 3) {
      out = "," substr(s, length(s) - 2) out
      s = substr(s, 1, length(s) - 3)
    }
    return sign s out
  }

  function clip(s, w) {
    gsub(/\t/, "\\t", s)
    gsub(/\r/, "", s)
    if (length(s) <= w) return s
    return substr(s, 1, w - 1) "â€¦"
  }

  function by_count_desc(i1, v1, i2, v2) {
    if (v1 != v2) return (v1 > v2 ? -1 : 1)
    # stable-ish tie-breaker
    return (i1 < i2 ? -1 : (i1 > i2))
  }

  function draw(    n, i, k, pct) {
    if (!first && last_lines > 0) printf "\033[%dA", last_lines
    first = 0

    printf "\033[J"
    printf "%15s %8s  %s\n", "count", "percent", "value"

    n = asorti(c, keys, "by_count_desc")
    for (i = 1; i <= n; i++) {
      k = keys[i]
      pct = (total ? 100 * c[k] / total : 0)
      printf "%15s %7.2f%%  %s\n", commify(c[k]), pct, clip(k, valw)
    }

    last_lines = 1 + n
  }

  {
    c[$0]++
    total++

    now = systime()
    if (now - last >= INTERVAL) { draw(); last = now }
  }

  END { draw(); printf "\n" }
  '
}
